1.自定义函数   2.正则表达式 3.函数背记
**文件**
```
// 文件属性
	// 1. 文件分类
	// 		file 	文件
	// 		dir 	文件夹/目录
	
	// 2. 检测文件的类型
		var_dump( filetype('05-file.php') );
		var_dump( filetype('a') );
		var_dump( filetype('log.txt') );
		var_dump( filetype('b.rar') );
		var_dump( filetype('c') );
		var_dump( filetype('e.zhouyao123') );

	// 3. 检测文件大小
	// 		只支持文件, 不支持目录
		var_dump( filesize('05-file.php') );
		var_dump( filesize('a') );

	// 4. 检测文件/目录是否存在
		var_dump( file_exists('05-file.php') );
		var_dump( file_exists('05-file.php123') );
		var_dump( file_exists('a') );

	// 5. 检测文件是否可读, 可写
		var_dump( is_readable('05-file.php') );
		var_dump( is_writeable('05-file.php') );

	// 6. 检测文件创建/修改/访问时间
		date_default_timezone_set('PRC');
		var_dump( date('Y-m-d H:i:s',filectime('05-file.php') ));
		var_dump( date('Y-m-d H:i:s',filemtime('05-file.php') ));
		var_dump( date('Y-m-d H:i:s',fileatime('05-file.php') ));
		
		
	// 文件路径
	// dirname() 		获取目录
	// basename() 		获取文件名

	$path = 'http://www.baidu.com/image/zh......ou.y.a.o.jpg?sex=女&age=15';
	echo dirname($path);
	echo '<br>';
	echo basename($path);
	echo '<hr>';
	
	


	// 获取 $path文件的扩展名
		$a = basename($path);
		echo $a;
		echo '<br>';
		$b = strtok($a, '?');
		echo $b;
		echo '<br>';
		$c = strrchr($b, '.');
		echo $c;

	// parse_url() 		适合解析网址
		$path = 'http://www.baidu.com:80/image/zh......ou.y.a.o.jpg?sex=女&age=15#xxx';
		var_dump( parse_url($path) );

	// pathinfo()  		适合解析盘符地址
		$path = 'C:/wamp/www/s76-2/0424/06-path.php';
		var_dump( pathinfo($path) );
		
	// 三元归一函数
	// opendir() 	打开目录, 返回值: 资源
	// readdir() 	读取资源, 返回值: 资源名 
	// closedir() 	关闭资源

	// is_file() 	判断是否为文件
	// is_dir() 	判断是否为目录
		// var_dump(is_file('./a/a1.txt'));
		// die;
		```
**PHP基础**（忍受孤独)
```
    1.php文件名
    格式：xxx.php
    规范：必须是英文，不要用中文（包括文件夹名）
    特殊符号：（‘’ “” * ？ ： < > \/ | ）
    
    2.PHP文件存目录： 根目录 www
                wampserver    www
                phpstudy      www
                xampp         htdocs
                mamp          htdocs
                ...
                
    3. 如何运行PHP文件
		* 必须先打开 集成环境
		* 打开浏览器
		* 在地址栏输入:  localhost  (进入本地的服务器)

	4. 重装环境
		项目代码:  www目录   复制到wamp以外

		数据库: wamp\bin\mysql\mysql5.7.11\data
    1. PHP是什么
			PHP: 超文本预处理器
			一句话: 一种用来开发动态网站的服务器脚本语言

	2. PHP 定界符
			所有PHP代码必须放在定界符里才能起作用
			定界符1: 
				<?php  php代码  ?> 		长风格定界符
			
			定界符2:
				<?     php代码  ?> 		短风格定界符
				PS: 
					短风格定界符, 服务器默认不开启
					如需开启, 需要修改配置文件
					配置文件地址:  wamp\bin\apache\apache2.4.18\bin\php.ini
					配置代码: short_open_tag = On | Off
					修改任意配置, 必须重启服务器才能起作用.

	3. PHP 向浏览器输出一句话
			echo '内容';

			PS: 内容可以识别 html标签

	4. 如果输出内容乱码, 则先声明编码方式
			header('content-type: text/html; charset=utf-8');   utf-8编码

	5. 注释
			单行: //
			单行: #
			多行: /*  * /

	6. 基本语法
			每条PHP命令 均以 分号 结尾;
			其中, 最后一条PHP命令, 可以省略分号.  (不推荐)

	
	

	//phpinfo();  // 查看PHP相关信息, 配置, 组件 ...
```
**变量**
```
变量  variable 		未知数   值不固定
	// 1. 格式
	// 		$变量名 = 值
		$x = 100;
		echo $x;
	// PS: 如果变量 没有赋值, 则被称之为 未定义的变量
		echo @$y;  // Undefined : 未定义
		// 如果不想看见错误, 在变量前面加@


	 2. 命名
        2.1 规范: 由数字, 字母和 下划线组成, 不能以数字开头
	 	          支持中文, 最好不要用中文.
		$abc123 = '范淑淑';
		echo $abc123;
		$_123 = '周垚';
		echo $_123;
		echo '<br>';
		// $123abc = '伟哥';
		// echo $123abc; 		// syntax error : 语法错误
		$帅哥 = '冯军';
		echo $帅哥;

	    2.2 区分大小写
		$a = '旺哥';
		echo $a;
		// echo $A;
		
	可变变量: 将一个变量的值 作为另一个变量的名 去使用
		$a = '晨哥';
		$晨哥 = '翔哥';
		// echo $晨哥;
		echo $$a;
		echo '<hr>';

	普通赋值
		$a = 100;
		$b = $a;  // $b = 100
		$b = 500;
		echo $a;
		echo '<br>';
		echo $b;
		echo '<hr>';


	引用变量: 将一个变量的内存地址 给了 另一个变量
		$a = 100;
		$b = &$a;   // $b = $a的内存地址,  两个变量共用同一个内存
		$b = 500;
		echo $a;
		echo '<br>';
		echo $b;   
```
**PHP数据类型**
```
 标量：   整形int     浮点型float 字符串string  布尔型bool
 复合：  array()数组   对象object
 特殊： resource资源   空null
    
    
    int：
        最大整形 PHP_INT_MAX    ps:超过最大整形则自动转换为浮点型
        进制数：
        二进制0-1  以0b开头
        八进制：0-7 以0开头
        十进制：
        十六进制：0-9 a-f 以0x开头
        $a = 0b1110; // 0 * 2^0 + 1 * 2^1 + 1 * 2^2 + 1 * 2^3 = 14
		echo $a;
		$a = 010;  // 0 * 8^0 + 1 * 8^1 = 
		echo $a;
			$a = 0x10;
		$a = 0x123;
		echo $a;
	    // 任意进制 -> 十进制
	    // 基数 * 进制 ^ 次方 +  ...
	    
    float:
        浮点数：小数
        精度：14位 四舍五入
        $a = 1.1234567890123456789;
		var_dump($a);
		
		科学计数法
		$a = 2e3; // 2 * 10^3
		echo $a;
		var_dump($a);

        奇葩现象：浮点数不适合二进制
    bool:
        布尔型：bool    （状态）
            值：true | false
          场景：用于判断
          
        有7种情况与false等价，其余都是true
            1.false
            2.0
            3.0.0
            4.null
            5.未定义变量
            6.空数组array()  []
            7.‘’ 或 ‘0’
    string:
        格式1：单引号
        格式2：双引号
        格式3：自定义定界符
        
      自定义定界符
	    从<<<之后, 开始定界 和 结束定界符前后不能有 任何多余的字符
	    
	    $c = <<<zhouyao
		<table border="1" cellspacing='0' cellpadding='10'>
			<caption> 荣耀排行 </caption>
			<tr>
				<td> 关羽 </td>
				<td> 后羿 </td>
				<td> 李白 </td>
			</tr>
			<tr>
				<td> 达摩 </td>
				<td> 亚瑟 </td>
				<td> 亚索 </td>
			</tr>
			<tr>
				<td> 小乔 </td>
				<td> 貂蝉 </td>
				<td> 大乔 </td>
			</tr>
		</table>
zhouyao;
	echo $c;
	var_dump($c);
    单双引号的区别：
        单引号：
                不解析变量，速度快
                不解析转义字符，但解析转义转义字符
        双引号：解析变量，速度慢
                解析转义字符
        共性：不能自插，可以互相插入
    
    转义字符 \  :可以为普通字符赋予特殊意义，也可以取消字符的特殊意义
        \n  换行
        \r  回车
        \t  制表符
    
    
    数组：
        数组：一堆变量的集合
        组成：由下标/键/偏移量 和值组成  （键值对）
    分类：
        索引数组：下标为int
        关联数组：下标为string
        混合数组：下标int和string
     索引键:
	 	当下标一个都没有时, 下标默认从0开始
	    当存在部分下标时, 不指定下标, 从已有的最大下标+1 
	 关联键
	 	true  => 1  => '1' => 1.0
	 	false => 0  => 0.0 => '0'
	 	null  => '' => 未定义变量  
        格式1：
       $数组名[ 下标/键/偏移量 ] = 值
        $a[] = 10;
        var_dump($a);
        格式2：
       $数组名 = [键1=>值1, 键2=>值2, ... ];
        格式3：
       $数组名 = array( 键1=>值1, 键2=>值2, ... );
       
        修改数组中的一个，通过下标改
        获取数组 中的一个通过下标查
        删除数组中的一个通过下标删
        
    对象：一切皆对象，后期会详细学习
    
        $对象名 = new 类名
        $obj = new stdClass;
		var_dump($obj);
		
	资源：resource
	    资源：文件，图片， ... 后期会详细学习
	    // 例如:  打开一个文件
		$resource = fopen('01-string.php', 'r');
		var_dump($resource);

    空：
        什么都没有，没有内存地址
        有3种情况下直接为空：
            未定义的变量
            被删除的变量
            直接赋值为空
    
    unsert()删除变量
    empty()判断一个变量是否为假，假：返回true  真：返回false
    isset() 判断一个变量是否有内存地址，有：返回true  没有：返回false
    
    
    // echo  		
	// 	* 只能输出int, float, string, resource
	// 	* 语法结构
	// 	* 没有返回值
	// 
	// print | print()
	// 	* 只能输出int, float, string, resource
	// 	* 语法结构 | 函数
	// 	* 返回值: 整形
	// 
	// print_r()
	//  * 除了布尔和空类型不能输出, 其余都可以
	//  * 函数
	//  * 返回值: 布尔型
	// 
	// var_dump()
	// 	* 都可以输出
	// 	* 函数
	// 	* 没有返回值
	
```
**常量**
```
    常量：恒定不变的值
    格式1：
        const 常量名 = 值；
        ps:
            1.常量不需要$符
            2.常量区分大小写
            3.常量不允许被重新赋值
            4.常量不允许被重新定义
    格式2：
        define('常量名'，'常量值'，[true/false])
                true:不区分大小写
                false:区分大小写
                
```
**数据类型的自动转换**
```
PHP 弱类型语言
JAVA 强类型

数据类型的自动转换
    bool->int
    var_dump( true + 1 ); // 2		true -> 1
	var_dump( false + 1 ); // 1		false -> 0
    
    bool->float
    var_dump( true + 1.5 ); // 2.5 	true -> 1.0
	var_dump( false + 1.5); // 1.5 	false -> 0.0

    string->int
    var_dump( '100' + 200 ); // 300 	'100' -> 100
	var_dump( 'abc' + 200 ); // 200 	'abc' -> 0
	var_dump( 'a1b2c3' + 200 ); // 200 	'a1b2c3' -> 0
	var_dump( '1a2b3c' + 200 ); // 201 	'1a2b3c' -> 1
	var_dump( '2b' + 200 ); // 202 		'2b' -> 2
	var_dump( 'b2' + 200 ); // 200 		'b2' -> 0
	var_dump( '#2' + 200 ); // 200 		'#2' -> 0
	var_dump( '2#' + 200 ); // 202 		'2#' -> 2
	
	string->float
	var_dump( '1.5' + 200 ); // 201.5 	'1.5' -> 1.5
	var_dump( 'a1.5' + 200 ); // 200 	'a1.5' -> 0
	var_dump( '1.a5' + 200 ); // 200 	'1.a5' -> 1.0
	var_dump( '1.e5' + 200 ); // 100200 '1.e5' -> 100000
	var_dump( '1.ee5' + 200 ); // 201 	'1.ee5' -> 1.0
	var_dump( '1.2.3' + 200 ); // 201.2 '1.2.3' -> 1.2

    int->float
    var_dump( 100 + 100.5 ); // 200.5 	100 -> 100.0
    
    // bool -> string 
	var_dump( true + 'abc');
	var_dump( true + '.abc');
	var_dump( true + '.5abc');
	
强制类型转换：
    / 1. 临时转换
	// 		1.1 通过运算符 来转换   (类型)变量
			$a = '2周垚配一个能够激情四射, 澎湃不已的女人: 冯军 ';
			var_dump(  (bool)$a  );
			var_dump(  (int)$a  );
			var_dump(  (float)$a  );
			var_dump(  (string)$a  );
			var_dump(  (array)$a  );
			var_dump(  (object)$a  );
			// var_dump(  (resource)$a  );
			// var_dump(  (null)$a  );
			echo '<hr>';

	// 		1.2 通过函数 来转换
			var_dump( boolval($a) );
			var_dump( intval($a) );
			var_dump( floatval($a) );
			var_dump( strval($a) );
			var_dump($a);
			echo '<hr>';

	// 2. 永久转换
			settype($a, 'int');
			var_dump($a);
			settype($a, 'string');
			var_dump($a);

```
**算术运算符**
```
    + - * /
    % 取模 求余数
        正负结果：取决于第一个数的正负，而第二个永远都是取绝对值
        结果范围：m - n  x%(n-m+1) + m
        
        ++:  自增 $a++  => $a  =  $a + 1
        --: 自减 	
        . : 拼接变量与变量
            变量与字符串

```
**赋值运算符**
```
   // = 	赋值
	// += 	a += b 		=>  a = a + b
	// -= 	a -= b  	=>  a = a - b
	// *=
	// /=
	// %=   a %= b 		=>  a = a % b
	// .=   a .= b  	=>  a = a . b
```
**比较运算符**
```
	// 比较运算符:  true | false
	// > >=
	// < <=
	// == 		判断两边的值是否相等
	// === 		全等: 数值相等, 类型相等
	// != 或 <>	数值不等
	// !==  	全等时:false, 其余都是true
```

**逻辑运算符**
```
	// 逻辑运算符: true / false 
	// 	逻辑与 	&& 	and	两边为真即为真, 一边为假即为假
	// 					如果前面已经有假了, 后面则不再执行

	// 	逻辑或  ||  or	两边为假即为假, 一边为真即为真
	// 					如果前面已经有真了, 后面则不再执行

	// 	逻辑非  ! 		真即是假, 假即是真
	// 
	// PHP运算中, 用符号
	// MySQL中,   用单词
```
**三元运算符**
```
     一元运算符 	++ -- !  (类型)
	 二元运算符   + - * / ....
	 三元运算符   ?:
	
	 完整格式:
	 		条件表达式 ? 成立 : 不成立 
	// get 		服务器以 $_GET 接收
	// post 	服务器以 $_POST 接收
```
**流程控制**
```
    1.顺序结构：默认代码依次从上往下执行
    2.分支结构：通过if/switch来进行选择
    3.循环结构
    
    if适合定值，也适合范围
    分支1：
        if(条件表达式){
            true
        }else{
            false
        }
    分支2：
        if(条件表达式)只影响紧跟在后面的一句话
    分支3：
    
	     if( 条件表达式 ){} 		影响到 {} 内所有代码
	     
    	// switch
	$job = '坦克';
	$job = '射手';
	$job = '逗比';


	switch( $job ){
		case '坦克': echo '白起 ';
		case '战士': echo '花木兰 ';
		case '刺客': echo '李白 ';
		case '射手': echo '后羿 ';
		case '法师': echo '妲己 ';
	}
	echo '<hr>';


	$job = '坦克';
	$job = '射手';
	$job = '逗比';

	// 通过 break 来限制后面代码的执行
	// break: 直接跳转到 分支以外
	switch( $job ){
		case '坦克': echo '白起 '; break;
		case '战士': echo '花木兰 '; break;
		case '刺客': echo '李白 '; break;
		case '射手': echo '后羿 '; break;
		case '法师': echo '妲己 '; break;

		// 当 选择不存在的case时, 自动跳转到default
		default: echo '不支持该职业';
	}
	echo "<hr>";
	
	
循环结构：
    while( 条件表达式){
        循环体
    }
    	// 当 条件表达式 = true,  则执行循环体, 当循环体全部执行完了, 再去条件表达式
		//   		     = false, 则结束循环, 执行循环外的代码
	

	 do{}while
		
		// do{
		//  	循环体
		// }while( 条件表达式 );
		
		// PS: 无论条件是否成立, 循环体都会执行1次

		// 功能相同, 位置相同, 用循环
    
    	
	 	for( 1-初始值 ; 2-循环条件 ;  3-循环增量){
	 		4-循环体
	 	}

``` 
**for与html的混合写法**

		<?php for( ; ; ):   ?>
			html 代码
		<?php endfor   ?>
	 

	 if 与 html 混合写法
	
		<?php if(  ):   ?>
			html 代码
		<?php endif   ?>


		<?php if(  ):   ?>
			html 代码 true环境
		<?php else:    ?>
			html 代码  false环境
		<?php endif   ?>



		<?php if(  ):   ?>
			html 代码 true环境
		<?php elseif():    ?>
			html 代码  二次true环境
		<?php else:    ?>
			html 代码  二次false环境
		<?php endif   ?>
	    
	    foreach 与 html 混合写法
		<?php  foreach():  ?>
			html代码
		<?php  endforeach  ?>
**特殊流程控制**
```
1.continue 直接跳过当前一轮循环，直接进入下一轮 
2.break    直接跳转到循环外面
3.die | exit() 直接结束程序
```
**函数**
```
  	    函数:  将一堆代码 整合在一起, 形成一个完整的功能
	    分类:
	 	系统函数  : 背记
	 	自定义函数: 自主开发
	
	   自定义函数:
	 	function 函数名(   [参数1, 参数2, .... ]  )
	 	{
	 		函数体
	 	}
	 	
	 	
	 	调用函数:
	 		函数名()
	 		函数名( 参数1, 参数2, ...)
	 	
	 	PS:
	 	- 不调用不会自动执行, 语法照常解析
	 	- 多个函数互相不影响, 可以互相调用
	   	- 调用函数 和 定义函数的位置 前后没有关系
	   	
	    函数名
	   1. 命名规范:
	 		* 由数字, 字母和下划线组成, 但是不能以数字开头
	 		* 不区分大小写
			* 命名不能重复定义 (包括系统函数名)
	 
	 2. 命名形式
	 		* 驼峰命名法   推荐
	 			从第二个单词开始, 首字母都要大写
	 			addUserName()
	 			
	 		* 帕斯卡命名法
	 			每个单词的首字母都大写
	 			AddUserName() 
	 			
	 		* 下划线命名法
	 			每个单词之间用 下划线 隔开
	   			var_dump()
    格式：
        function 函数名（参1，参2）
        {
            函数体
            [return:返回值]
        }
    当没有return时，默认返回null
    当有return时，可以返回所有类型

```

**参数分类**
```
    实际参数: 调用函数时给的参数, 简称: 实参  argument
    形式参数: 定义函数时给的参数, 简称: 形参  parameter
    
    function add($a = 1, $b = 2)
	{	
		echo 'a = '.$a.'<br>';
		echo 'b = '.$b.'<br>';

		$sum = $a + $b;
		return $sum;
	}

	// 实参个数 = 形参个数 	完美
	echo add(10, 20);
	echo '<hr>';

	// 实参个数 < 形参个数   多余的形参, 要么当成未定义变量
	// 									 要么采用默认值
	echo add(10);
	echo '<br>';
	echo add();
	echo '<hr>';

	// 实参个数 > 形参个数 	多余的实参, 被抛弃
	echo add(10, 20, 30, 40);
	
	
	// 当实参个数 不确定时, 形参通过三种函数来接收
	// 	func_get_args() 	以数组形式, 接收所有的实参
	// 	func_get_arg(n) 	获取实参列表下标为 n 的值
	// 	func_num_args()  	获取实参的总个数
	
	function add()
	{
		var_dump( func_get_args() );
		// var_dump( func_get_arg(1) );
		// var_dump( func_num_args() );

		$sum = 0;

		// $sum = $sum + func_get_arg(0);
		// $sum = $sum + func_get_arg(1);
		// $sum = $sum + func_get_arg(2);
		// $sum = $sum + func_get_arg(3);
		// $sum = $sum + func_get_arg(4);

		for($i = 0; $i < func_num_args(); $i++){
			$sum = $sum + func_get_arg($i);
		}


		echo $sum;

	}

	add(10);
```
**创建表格**
```
    // 创建一个 多行多列的表格
	// 功能相同, 位置相同, 用循环
	// 功能相同, 位置不同, 用函数

	function createTable($rows = 2, $cols = 2)
	{
		echo '<table border="1" width="800" height="200">';
			for($i = 0; $i < $rows; $i++){
				echo '<tr>';

				for($j = 0; $j < $cols; $j++){
					echo '<td> '.( $i * $cols + $j ).'  </td>';
				}

				echo '</tr>';
			}
		echo '</table>';
	}

	createTable();
	createTable(10,10);
	createTable(5,3);

```
**变量的作用域**
```
局部变量：在函数内申明的变量,默认不能在全局环境中使用
全局变量：在函数外申明的变量，默认不能在局部中使用

全局变量 如何在局部变量中使用
        $a = 10;
		test();
		function test()
		{
			// echo $a;
			// 格式: $GLOBALS['全局变量名']
			echo $GLOBALS['a'];  // $GLOBALS 超全局数组
		}
		echo '<hr>';

	// 局部变量 如何在全局环境中使用
		function test2()
		{
			global $b;
			$b = 20;
		}

		test2();
		echo $b;
	静态变量：特殊的局部变量
	函数结束时，不会消失，当再次调用此函数时，直接获取上一次的静态值
	ps:静态变量不能在全局中使用
	
```
**遍历数组**
```
索引遍历：只遍历下标为有规律的数字
$a = ['a','b','c','d'];
	var_dump($a);

	for($i = 0 ; $i < 4 ; $i++){
		echo $a[$i].' ';
	}
	echo '<hr>';


	// 指针遍历
	$a = [4=>'a',2=>'b',1=>'c',9=>'d'];
	var_dump($a);
    foreach遍历
    foreach(数组名 as 键 => 值){
        循环体
    }
    
    foreach( 数组名 as 值 ){
			循环体
		}

```
**预定义数组**
```
$_GET：存储以get方式传送过来的值
$_POST: 存储post方式传送过来的值
    当action带参数时，
    method=post时，$_post接收表单值，$_get接收参数
    method=get时，$_get接收表单值，而参数丢失
    解决方案：
        把参数改成隐藏域进行传输
    <!-- 解决方案: -->
  <form action="08-get.php?b=999" method="get">
  	<input type="hidden" name="b" value="999">
 	<input type="text" name="a">
 	<input type="submit">
 </form>
```
**错误类型**
```
 1.语法错误:  最常见, 但最容易修复的错误, 终止程序的执行
   运行时错误: 比较常见, 容易修复, 不终止程序的执行
   逻辑错误: 比较常见, 最麻烦, 不容易修复(不报错, 结果是错的), 不终止程序

 2. 错误级别
	// * 1) 致命错误 error 	: 程序则不再执行
	// * 2) 警告错误 warning: 警告, 不会终止程序
	// * 8) 提示错误 notice : 提示, 
	
	// 屏蔽错误(临时性, 只对本文件有效)
	// 方法1:
	// 	在错误变量前面 加@符   错误抑制符
		echo @$a;
		echo @strrev();

	// 方法2:   推荐
	// 	通过函数 error_reporting() 来屏蔽错误, 位置比较靠前
	// 							0 			禁用错误报告
	// 							E_ALL 		显示所有错误报告
	// 							E_ERROR 	只显示 error 级错误
	// 							E_WARNING 	只显示 warning 级错误
	// 							E_NOTICE 	只显示 notice 级错误
	// 							E_ALL ^E_NOTICE 	除了 notice 不报, 其余都报
	// 							E_ALL & ~E_NOTICE 	除了 notice 不报, 其余都报
	// 							E_ALL ^E_WARNING 	除了 warning 不报, 其余都报
	// 							E_ALL & ~E_WARNING 	除了 warning 不报, 其余都报
		error_reporting(0);
		error_reporting(E_ALL);
		error_reporting(E_ERROR);
		error_reporting(E_WARNING);
		error_reporting(E_NOTICE);
		error_reporting(E_ALL ^E_NOTICE);
		error_reporting(E_ALL & ~E_NOTICE);
		echo $a;
		echo strrev();
		
		
	// 屏蔽错误(配置文件)
	// 位置: wamp/bin/apache/apachex.x.x/bin/php.ini
	// 
	// 配置1:
	// 	display_errors = On 		开启错误提示
	// 					 Off 		关闭错误提示

	// 配置2:
	// 	error_reporting =  与 error_reporting函数的参数一致
		

	// 配置3:
	// 	ini_get() 	获取配置的值
	// 	ini_set()   设置配置的值(临时)
    
    // 自定义报错
	// trigger_error(报错信息, 错误类型)
	// 							E_USER_ERROR
	// 							E_USER_WARNING
	// 							E_USER_NOTICE
	
	// 错误日志
	// error_log(p1, p2, p3)
	// 	p1: 报错信息 
	// 	p2: 错误类型 	3
	// 	p3: 目标文件

```
**正则匹配**
```
    preg_match_all(正则, 对象 [, 结果])
    正则替换：
    preg_replace(search, replace, obj) 
	 返回值: 替换后的结果
	 preg_grep(正则, 数组) 	过滤 	
```
**时间**
```
1.时区
UTC:默认，世界标准时间
PRC:中华人民共和国
设置时区：
date_default_timezone_set()
获取时区：
date_default_timezone_get()

2.单位：s
获取当前时间：
1970-现在的秒数
echo time()  时间戳
3.格式化时间：
date('格式',[时间戳])
echo date('y-m-d H:i:s');
4.创建时间点：
mktime(时，分，秒，月，日，年)；
5.字符串转时间戳
strtotime
echo strtotime(date('Y-m-d H:i:s')).'<br>';
6. 如何用最短的代码写出昨天的时间
	echo date('Y-m-d H:i:s',strtotime('-1 day')).'<br>';

```
递归
```
    // 计算 目录的大小
	echo dirSize('a');

	function dirSize($dir)
	{
		// 1. 打开目录
			$handle = opendir($dir);
			$size = 0;

		// 2. 读取资源
			while( $file = readdir($handle) ){
			 	// 2.1 排除. 和 .. 
					if($file == '.' || $file == '..'){
						continue;
					}

			 	// 2.2 凑完整路径
					// echo $file.'<br>';
					$path = $dir.'/'.$file;

			 	// 2.3 判断是否为文件
					if( is_file($path) ){
						$size += filesize($path);
					}
			 	// 2.4 判断是否为目录
					if( is_dir($path) ){
						$size += dirSize($path);
					}

			}
		// 3. 关闭资源
			closedir($handle);

			return $size;
	}
    
    
    
    // copy(复制谁, 复制到哪儿去)
	// 
	// PS: 两个参数 都必须是 文件, 不能是目录
	// 
	// copy('01-dirSize.php', 'a/01-dirsize.php');
	// copy('01-dirSize.php', 'a/');
	

	// 创建目录: mkdir()
	// 删除目录: rmdir() 		只能删除空目录
	// 
	// 创建文件: touch()
	// 删除文件: unlink()
		
	// mkdir('./abc');
	// touch('abc/abc1.txt');
	// unlink('abc/abc1.txt');
	// rmdir('./abc');
	
	copyDir('./a', './b');	

	function copyDir($src, $dst)
	{
		// 1. 判断$dst 是否存在
			if( !file_exists($dst) ){
				mkdir($dst);
			}

		// 2. 打开 src
			$handle = opendir($src);

		// 3. 读取 src
		 	while( $file = readdir($handle) ){
		 		// 3.1 排除. 和.. 
		 			if( $file == '.' || $file == '..'){
		 				continue;
		 			}

		 		// 3.2 凑完整路径
		 			// ./a/a1.txt   =>  ./b/a1.txt
		 			$srcPath = $src.'/'.$file;
		 			$dstPath = $dst.'/'.$file;

		 			// echo $srcPath.'<br>'.$dstPath.'<hr>';

		 		// 3.3 判断是否为文件
		 			if( is_file($srcPath) ){
		 				copy($srcPath, $dstPath);
		 			}

		 		// 3.4 判断是否为目录
		 			if( is_dir($srcPath) ){
		 				// echo $srcPath.'<br>'.$dstPath.'<hr>';
		 				copyDir($srcPath, $dstPath);
		 			}
		 	}


		// 4. 关闭 src 
			closedir($handle);
			
	}
	
	delDir('./a');

	function delDir($src)
	{
		// 1. 判断$src 是否存在, 直接返回
			if( !file_exists($src) ){
				return false;
			}

		// 2. 打开 src
			$handle = opendir($src);

		// 3. 读取 src
		 	while( $file = readdir($handle) ){
		 		// 3.1 排除 . 和.. 
		 			if($file == '.' || $file == '..'){
		 				continue;
		 			}

		 		// 3.2 凑完整路径
		 			$path = $src.'/'.$file;

		 		// 3.3 判断是否为文件
		 			if( is_file($path) ){
		 				unlink($path);
		 			}

		 		// 3.4 判断是否为目录
		 			if( is_dir($path) ){
		 				delDir($path);                                                                                                            
		 			}
		 	}


		// 4. 关闭 src 
			closedir($handle);
			
		// 5. 删除当前目录
			rmdir($src);
	}
	
	// 重命名 rename(改谁的名字, 改成什么名字  )
	// rename('./test.txt', 'test2.txt');
	// rename('./test2.txt', 'a');

	// 剪切
	rename('./test.txt', 'b/test2.txt');

	// PS: 参数要的是文件, 而不是文件夹


```
**文件加载**
```
include '文件路径'
include('文件路径')
特性：什么时候执行到include，才会去加载
      可以重复加载, 如果避免重复加载, 通过include_once 来实现
      如果加载出错, 不会终止程序
require '文件路径'
require('文件路径')
特性：什么时候执行到require，什么时候才会去加载
      可以重复加载，如果避免重复加载, 通过require_once 来实现
      如果加载出错, 终止程序
```
**文件内容**
 ```
 1.向文件赋予内容
		 	file_put_contents('目标文件', '内容')
		 	原理: 如果文件不存在, 则自动创建. 
		 		  如果文件存在, 则先将文件大小截为0, 再填充内容
		 		  
2.向文件获取内容
		    file_get_contents('目标文件'); 
		    echo  file_get_contents('x.txt');
3. 打开文件
	 	fopen('目标文件','打开方式') 
		   $handle = fopen('x.txt', 'r');
		   $handle = fopen('x.txt', 'r+');
	       $handle = fopen('x.txt', 'w');
		$handle = fopen('x.txt', 'a');
4. 读取文件内容
	 	fread(资源, 字节大小)
			 echo fread($handle, 1);
			 echo fread($handle, 1);
			 echo fread($handle, 1);
			 echo fread($handle, 1);
			 echo fread($handle, 1);
			 echo fread($handle, 5);
		     echo fread($handle,  filesize('x.txt')  );
5. 写入文件内容
	     fwrite(资源, 内容)
		 fwrite($handle, 'i love you');
6. 关闭资源
	    fclose(资源)
		fclose($handle);

```		    
**文件上传**
```

    <!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>

	<form action="09-upload.php" method="post" enctype="multipart/form-data">
		<!-- <input type="hidden" name="MAX_FILE_SIZE" value="23000"> -->
		<input type="file" name="icon">
		<input type="submit">
	</form>
	
</body>
</html>




var_dump($_FILES); 

	$res = upload();
	var_dump($res);

	// 返回值区分对错
	// 	布尔型 
	// 	不同的数据类型
	function upload($savePath = 'upload',  $allowType = ['image'])
	{
		// 1. 判断上传的文件error号 		0:成功  其余都是错误的
			$key = key($_FILES);
			if( empty($key) ){
				return '您上传的文件过大, 请重新上传';
			}


			for($i = 0; $i < 3; $i++){

				$error = $_FILES[$key]['error'][$i];
				if( $error > 0  ){
					switch($error){
						case '1': return '您上传的文件过大, 请重新上传'; break;
						case '2': return '您上传的文件过大, 请重新上传'; break;
						case '3': return '请检查您的网络'; break;
						case '4': return '请选择您的文件'; break;
						case '6': return '服务器繁忙'; break;
						case '7': return '服务器繁忙'; break;
					}
				}

				// 2. 判断 是否是从post协议过来的
					$tmp = $_FILES[$key]['tmp_name'][$i];
					if( !is_uploaded_file( $tmp ) ){
						return '非法上传'; 
					}

				// 3. 判断文件类型
					// 3.1 获取文件的类型
					$type = strtok($_FILES[$key]['type'][$i], '/');

					// 3.2 判断允许的类型
					if( !in_array($type, $allowType) ){
						return '文件类型格式不正确';
					}

				// 4. 设置唯一的文件名
					$suffix = strrchr($_FILES[$key]['name'][$i] , '.');
					$name = date('Ymd').uniqid().$i.$suffix;

				// 5. 设置 存储目录
					$dir = $savePath.date('/Y/m/d/');
					if( !file_exists($dir) ){
						mkdir($dir, 0777, true);
					}

				// 6. 移动 文件到 存储目录
					if( move_uploaded_file($tmp, $dir.$name) ){
						// return [$name];
						$arr[] = $name;
					}
			}

			return $arr;
	}

```
**数据库**
```
数据库: 存储数据的仓库
		按照数据结构来存储, 管理数据的仓库
	
		库: database
		表: table
	

	种类:
		Oracle
		SQL Server 	
		MySQL 

	MySQL:
		免费
		开源 
		事务 	
		跨平台

	1. 登录数据库必备条件
		1. 服务器环境开启
		2. 服务器IP地址/主机名
			本地可用 localhost

		3. 用户名 				wampserver  : root
		4. 密码 			 	wampserver  : 空
	

	2. 基本语法
		数据库每条命令以 分号 作为结束符
		
		命令框:
			右键空白 -> 命令列界面

	3. 命令
		设置密码
			set password = password('密码')

		查看数据库
			show databases

		创建数据库
			create database `库名`
			create database if not exists `库名` 		推荐


			`` : 实体化,   关于 库名, 表名, 字段名 必须加 
	
		删除数据库
			drop database `库名`

		查询数据表
			show tables;

		使用数据库
			use `库名`;

		创建数据表
			create table [if not exists] ` 表名`(
				`字段名` 	字段类型 	字段属性,
				`字段名` 	字段类型 	字段属性,
				`字段名` 	字段类型 	字段属性,
				...
				`字段名` 	字段类型 	字段属性 		最后一个 不能写逗号
			)engine=引擎 default charset=编码
			
MyISAM  和 InnoDB 的区别
1. 事务支持
	MyISAM: 强调的是性能, 查询操作执行速度比InnoDB快, 但不支持事务
	InnoDB: 提供事务, 外键等高级数据库功能 

2. 全文索引 FULLTEXT
	MyISAM: 支持
	InnoDB: 不支持, 但可以用sphinx技术全文索引

3. 表总行数
	MyISAM: 保存表总行数. 	用count()会直接获取保存的总行数
	InnoDB: 未保存.   	 	用count()会遍历整表, 消耗巨大
	注意:
		以上两种在用 count() 并包含where条件时,操作一样

4. CURD操作
	MyISAM: 在执行大量的select操作时, MyISAM速度较快
	InnoDB: 在执行大量insert,update和delelte时, InnoDB速度较快
	注意:
		整表删除时, InnoDB不会重建表, 而是一行一行删除
		如果要清空大量的数据表时, 推荐使用 truncate table

5. 行锁,表锁
	MyISAM: 支持表锁
	InnoDB: 支持表锁 和 行锁(默认)

总结: 对于多读少写,重性能, 建议采用MyISAM
      对于大数据项目,需要事务, 建议采用InnoDB
      
一 	操作数据表中的数据记录（DML语句）
		1.	使用INSERT语句向数据表中添加数据
			格式：
			INSERT INTO 表名 [(字段名1,字段名2,…字段名n)] VALUES(‘值1’,‘值2’,…,’值n’);
			或者
			INSERT INTO 表名 [(字段名1,字段名2,…字段名n)] VALUES(‘值1’,‘值2’，…，‘值n’),VALUES(‘值1’,‘值2’,…,’值n’);
			
		2.	使用UPDATE语句更新数据表中已存在的数据
			格式：
			UPDATE 表名 SET 字段名=表达式 [,…][WHERE 条件]

		3.	使用DELETE语句删除数据表中不需要的数据记录
			格式：
			DELETE FROM 表名 [WHERE 条件][ORDER BY 字段][LIMIT 行数]
	通过SQL命令查询数据表中的数据
		1. 格式
			SELECT [ALL|DISTINCT]{*|table.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]}
			FROM 表名
			[WHERE子句]
			[GROUP BY..]
			[HAVING..]
			[ORDER BY..]
			[LIMIT count];
		2. 选择特定的字段
		3. 使用AS子句为字段取别名
		4. DISTINCT关键字的使用
		5. 在SELECT语句中使用表达式的列
		6. 使用WHERE子句按条件检索
		7. 根据空值（NULL）确定检索条件
		8. 使用BEETWEEN AND进行范围比较查询
		9. 使用IN进行范围比对查询
		10. 使用LIKE进行模糊查询
			占位符：   _   	一个字符    
			           % 	任何数量的任意字符
		11. 多表查询（连接查询）
		12. 嵌套查询（子查询）
		13. 使用统计函数
				COUNT()
				SUM()
				AVG()
				MAX()
				MIN()
		14. 使用ORDER BY对查询结果排序  
			DESC 降序操作
			ASC  升序操作 （默认）
		15. 使用LIMIT
		16. 使用 GROUP BY 进行 分组

三 	MySQL 运算符
		1. 算术运算符
			+	  -	   *	  /		 DIV 	 % 	  MOD
		2. 比较运算符
			数据列类型						说明										取值范围
			=								a=b									若操作数a与操作数b相等，则为真
			<=>								a<=>b								若a与b相等，则为真，可以用于NULL值比较
			!=或<>							a!=b或a<>b							若操作数a与b不相等，为真
			<								a<b									若操作数a小于b，为真
			<=								a<=b								若操作数a大于b，为真
			>								a>b									若操作数a大于b，为真
			>=								a>=b								若操作数a大于等于b，为真
			IS NULL							a IS NULL							若操作数a为NULL，为真
			IS NOT NULL						a IS NOT NULL						若操作数a不为NULL，为真
			BETWEEN							a BETWEEN b AND c					若a在b和c之间，为真
			NOT BETWEEN						a NOT BETWEEN b AND c				若操作数a不在b和c之间，为真
			LIKE							a LIKE b							SQL模式匹配，若a匹配b，为真
			NOT LIKE						a NOT LIKE b						SQL模式匹配，若a不匹配b，则为真
			IN								a IN (b1,b2….)						若a等于b1,b2,b3,…中的某一个，则为真
		3. 逻辑运算符
			操作符							语法										描述
			AND 或 &&						a AND b 或 a && b					逻辑与，若两个操作数同时为真，则为真
			OR 或 ||						a OR b 或 a||b						逻辑或，只要有一个操作数为真，则为真
			XOR								a XOR b								逻辑异或，若有且仅有一个操作数为真，则为真
			NOT 或 ！						NOT a 或 ！a						逻辑非，若操作数为假，则为真
			
			
			
	创建数据表
		create table if not exists `表名`(
			`字段名` 	字段类型 	字段属性,
			`字段名` 	字段类型 	字段属性,
			...
			`字段名` 	字段类型 	字段属性
		)engine=引擎 default charset=编码

	字段属性
		* 主键索引	primary key		一般情况下, 一张表一个主键
		* 唯一索引	unique 			唯一
		* 自增 		auto_increment  该值自动+1	
		* 非空约束	not null 		不能为空
		* 默认值	default 			
		* 描述/注释	comment 
		* 无符号	unsigned 		绝对值
```
**增删改查**
```
-- 插入数据1 	单条
-- insert into 表名 values(所有字段值)
insert into `user` values(null, '周垚', default, md5('123456'), '18888888888', '2003-08-30', '岳阳', 'zhouyao@qq.com', 2, '拍黄片', 1, unix_timestamp() );

-- 插入数据2    多条
-- insert into 表名 values(所有字段值),(所有字段值),(),...

-- 插入数据3 	指定字段插入
-- insert into `表名`(`字段名1`, `字段名2`, ... )  values("","", )
insert into `user`(`tel`, `pwd`) values('17777777777', MD5('123456'));
-- insert into `表名`(`字段名1`, `字段名2`, ... )  values("","", ),(),(),(),()...


-- 更新数据
-- update 表名 set `字段名`="字段值", `字段名`="字段值" 		所有数据集体更新
update `user` set `sex` = 2, `status` = 2


-- update 表名 set `字段名`="字段值", `字段名`="字段值" where 条件
update `user` set `sex` = 1 where `id` = 1

-- 删除数据
-- delete from `表名` 		
delete from `user`;

-- delete from `表名` where 条件
delete from `user` where `name` is null

-- delete from `表名` [where 条件] order by 字段 asc/desc limit 行数
delete from `user` order by `birthday` desc limit 3

-- drop  	删除的是 结构
-- delete 	删除的是 数据


-- 聚合函数
-- count() 		统计
select count(`id`) from `user`

-- sum() 		求和
select sum(`id`) from `user`;

-- avg() 		平均值
select avg(`id`) from `user`;

-- max() 		最大值
select max(`id`) from `user`;

-- min() 		最小值
select min(`id`) from `user`;


-- 字符串函数 		
-- concat( 值1, 值2, 值3, ...) 		 拼接字符串
-- 值: 字段名 | 字符串
select concat(`id`,'----', `name`, '----', `address`) from `user`;


-- 数据库版本
select version();

-- 时间戳
select unix_timestamp();

-- 当前时间
select now();

-- 加密 
select md5('123456');
-- 查询数据
	-- select  
	-- from
	-- where
	-- group by
	-- having
	-- order by
	-- limit


-- 查询所有数据
-- select * from 表名
--  * : 所有的字段名
select * from `user`;


-- 查询指定字段
-- select 字段名1, 字段名2, ...
-- from 表名

select tel, pwd
from user


-- 根据条件查询数据
-- select 字段名1, 字段名2, ...
-- from 表名
-- where 条件
select tel, pwd
from user
where tel = '1111111' and pwd = '222222'

select id, tel, pwd, name
from user
where tel = '17777777777' and pwd = 'e10adc3949ba59abbe56e057f20f883e'

select id, tel, pwd, name
from user
where tel = '17777777777'

select id, tel, pwd, name
from user
where birthday >= '1996-01-01';



select id, tel, pwd, name
from user
where job is null;


select id, tel, pwd, name
from user
where job is not null;


select id, tel, pwd, name
from user
where birthday between '1996-05-05' and '1997-05-05';


select id, tel, pwd, name
from user
where name like '%周%';

select id, tel, pwd, name
from user
where name like '%周';


select id, tel, pwd, name
from user
where name like '_周';

-- % : 任意多个字符
-- _ : 任意一个字符


select id, tel, pwd, name
from user
where job in ('拍黄片', '老鸨')

-- 算术
select 1000 + 2000 

-- 别名
select 1000 + 2000 as `sum`
select count(id) as total from user;  -- 推荐
select count(id) total from user;     -- 不推荐


-- 取消重复
select distinct job from user

-- 排序
-- order by 字段 asc默认升序 | desc 降序
select id, name 
from user
order by id asc

select id, name 
from user
order by id



-- 分页
-- limit num 				从头开始, 连续查num条
-- limit key, num 			从下标key开始, 连续查num条


select id, name 
from user
limit 3;


select id, name 
from user
limit 0,3;


-- 分组查询
-- select 字段
-- from 表名
-- [where 条件] 				 分组前的筛选
-- group by 字段
-- having  	必须配合 group使用,  分组后的筛选

-- 注意: 分组sql, 只能以组为单位, 不能以个体单位, 强行获取个体, 只会获取到每组中第一条数据



-- 查询每个job 一共有多少人
select count(id)
from user
group by job



select count(id)
from user
where id < 9
group by job


-- 查询每个job 中最大的生日
select min(birthday)
from user
group by job


-- 查询每个job 中生日最大的那个名字  (错误)
select name, job, min(birthday)
from user
group by job

-- 查询总人数超过2人的 职业
select job 
from user
group by job
having count(id) > 2


-- 嵌套查询: 将一条sql的结果 作为另一条sql的"条件"来使用

-- 查询每个job 中生日最大的那个名字
select name, job, birthday
from user
where birthday in ('2009-11-25', '1994-06-28', '2010-06-15')


select name, job, birthday
from user
where birthday in (select min(birthday) from user group by job)




-- 多表联查
-- select  字段名, 字段名, ...
-- from 表名1, 表名2, ...
-- where  表与表之间的关系 (重点)


-- 查询 小张的所有收货地址
-- 表名.字段名 		
-- 库名.表名
select address.tel, address.name, address.address
from user, address
where user.id = address.uid and user.name = '小张'


select a.tel, a.name, a.address
from user as u, address as a
where u.id = a.uid and u.name = '小张'


select `a`.`tel`, `a`.`name`, `a`.`address`
from `user` as `u`, `address` as `a`
where `u`.`id` = `a`.`uid` and `u`.`name` = '小张'


-- 查询 每个job中 年龄最大的生日
select name, u.job, u.birthday  
from user u, test t 
where u.job = t.job and u.birthday = t.birthday


select name, u.job, u.birthday
from user as u, (select job, min(birthday) as birthday from user group by job) as t
where u.job = t.job and u.birthday = t.birthday


-- 查询每个job中最大的生日
select job, min(birthday) as birthday
from user
group by job


create table if not exists `address`(
	`id` 		int 		auto_increment primary key,
 	`uid` 		int 	 	not null	 comment '用户id',
	`name` 		varchar(20) not null 	 comment '收货人',
	`tel` 		char(11) 	not null  	 comment '收货电话',
	`address` 	varchar(50) not null  	 comment '收货地址'
)engine=myisam default charset=utf8;



create table test(
	`job` 	 	varchar(20),		
	`birthday`  date
)engine=myisam default charset=utf8;

```

**面向对象**
```
// 面向过程: 
	// 面向对象: 

	// 五子棋
	// 过程: 
	// 		开始游戏 -> 黑子先走 -> 画棋盘 -> 判断输赢 -> 
	// 				    白子落子 -> 画棋盘 -> 判断输赢 -> 2-7循环
	// 				    -> 结束游戏
	// 	
	// 对象:
	// 		开始结束游戏模块
	// 		落子模块
	// 		画棋盘模块
	// 		判断输赢模块
	// 		悔棋模块
	// 
	// 
	// 在后期的维护... 对象相对而言容易, 过程相对麻烦
	// 
	// 一切皆对象
	

	// 概念:
	// 	类   : 虚拟的 不存在 抽象化的
	// 	对象 : 真实的 存在   实例化的
	//  
	// 关系:
	// 	对象 就是类的实例化
	// 	类 就是对象的抽象化
	
    类的格式
		class 类名
		{
			属性 	(我有什么)
				格式:
					修饰符 属性名
					修饰符 属性名 = 属性值

			方法 	(我会什么)
				格式:
					修饰符 function 方法名( [参数1, 参数2, ... ] )
					{
						方法体
					}
		}
		 实例化
	         格式: 对象 = new 类名
	         通过 对象使用属性
	              格式: 对象->属性名
	         通过 对象使用方法
	               格式: 对象->方法名()
	               
	  1. 伪对象: $this 就相当于 当前对象
	 	格式: 
	 		$this->属性名
	 		$this->方法名()
	  2. 在同一类中, 一个方法 使用 另一个方法中的变量.  将变量转为属性即可

```         
**魔术方法**
```
魔术方法:  	在特殊条件下, 自动触发
	// 	__construct() 	构造方法
	// 		* 在实例化瞬间, 自动触发
	// 		* 作用: 初始化
	// 		* 位置: 属性的最后面, 方法的最前面
	 注意: 
	// 	当没有构造时,  方法名 和 类名相同时, 在实例化瞬间, 自动执行
	// 	存在构造时, 方法名 和类名相同时, 在实例化瞬间, 自动执行构造, 不执行同类名方法
析构方法 __destruct
	//	* 当对象被销毁时, 自动触发
	//			- 程序自然结束
	//			- 对象被覆盖
	//			- 对象被删除
	//	* 作用: 遗言
	//	* 位置: 方法的最后面
	//	* 不能带参数
	
	
	// __get() 		当访问非公有属性时, 自动触发
	// __set() 		当设置非公有属性时, 自动触发
	// __unset() 	当删除非公有属性时, 自动触发
	// __isset() 	当判断非公有属性是否设置时, 自动触发
	// __call() 	当访问不存在的方法时, 自动触发
	// __toString() 当输出对象时, 自动触发


```
**面向对象的三大特性**
```
 面向对象的三大特性
	 1. 封装性
	 2. 继承性
	 3. 多态性
 1. 封装性
	 	高内聚: 将对象的全部属性和方法结合在一起,形成一个不可分割的独立单位
	 	低耦合: 尽可能的隐藏内部属性和方法, 只留下部分接口与外部联系
	
	// 如何控制 与外部的联系
	// 修饰符:
	//  						类外 	本类 	子类
	// public  		公有的 		 √ 		 √ 		 √ 				国民儿子
	// private 		私有的  	 x 		 √ 		 x 				私生子
	// protected 	受保护的 	 x 		 √ 		 √ 				亲儿子
2. 继承性
	// 	定义:  儿子 继承 老子的一些东西
	// 	儿子:  派生类/扩展类/继承类   子类 
	// 	老子:  基类/ 基础类  		  父类
	
	// * 派生类 可以继承属性/方法, 除了私有的, 其余都可以
	// * 派生类 可以重写属性/方法, 如果再次使用父级方法, 通过parent::方法名()即可
	// * 支持单继承, 支持连续继承, 不支持多继承
	// * 访问级别: private > protected > public 
	// 	 继承时, 修饰符可以保留等级, 也可以降级, 但不能升级

	
	// 作用: 如果有很多类, 有共同的属性/方法, 可以写在基础类中, 子类继承即可
```
**静态方法**
```
// 关键词 static 
	// 
	// 格式:
	// 	修饰符 static 属性名
	// 	修饰符 static 属性名 = 属性值
	// 	修饰符 static function 方法名(){}

	// 特性:
	// 	1. 可以修饰属性/方法
	// 	2. 静态属性属于类, 不属于对象
	// 	3. 在静态方法内只能使用静态属性/方法
	// 	4. 静态属性/方法可以被继承
	
	
	// 静态访问格式:
	// 	类名::属性名
	// 	类名::方法名()

	// 注意: 
	// 	$this : 当前对象
	// 	self  : 当前类名
	// 	parent : 基础类

	class person
	{
		public $name = '老王';
		public static $money = 10000;

		public static function test()
		{
			echo '这是静态方法 <br>';
			// echo $this->name;
			// echo $this->money;
			echo self::$money;
			// echo self::$name;
		}
	}

	$a = new person;
	echo $a->name;
	echo '<hr>';

	// 静态不能通过对象来访问属性
	// echo $a->money; 	
	echo person::$money;
	echo '<hr>';


	// 静态方法可以通过对象, 也可以通过类名来访问( 推荐类名 )
	$a->test();
	person::test();
	echo '<hr>';


	// 继承静态
	class son extends person
	{

	}

	echo son::$money;
	son::test();
```
**const**
```
    类常量 const
    格式： 
        const 常量名 = 常量值
    特性：
        1.类常量属于类，不属于对象
        2.区分大小写
        3.类常量不能重新赋值
        4.类常量在同类中不能重新定义
        5.类常量可以继承，重写一次
        
        使用格式：
            类名::常量名
    例：
    class person
	{
		public $name = '老王';
		public $money = 10000;
		const SKILL = '老汉推车';
		// const SKILL = '老汉推车2';
		// define(); 		define 不能写在 属性位置

		public function test()
		{
			echo self::SKILL;
			// echo self::skill;
			// define();
			// self::SKILL = 'xxx';
		}
	}


	$a = new person;
	echo $a->name;
	echo '<br>';
	// echo $a->SKILL;  	类不能通过对象输出
	echo person::SKILL;
	echo '<hr>';

	$a->test();
	echo '<hr>';
```

**final**
```
最终 final
特性：
    1.可以修饰类，但不能被继承
    2.可以修饰方法，可以被继承，但不能被重写
    作用：限制一些原有的功能，祈祷保护父类结构的作用
    	final class person
	{
		public $name = '老王';
		public $money = 10000;

		public function test()
		{
		}
	}
	// class son extends person{}

	class zhouyao
	{
		final public $name = '达摩';

		// 最终方法
		final public function skill()
		{
			echo '断子绝孙脚 <br>';
		}
	}


	class son extends zhouyao
	{
		// public function skill()
		// {
		// 	echo '还我飘飘拳 <br>';
		// }
	}

	$a = new son;
	$a->skill();
```
**clone**
```
克隆对象
给对象做个副本，
ps:副本和本身互不影响，互相独立
标示符：将一个对象的标识付给另一个对象

class person
	{
		public $name = '老王';

		public function skill()
		{
			echo '调戏隔壁的周垚 <br>';
		}
	}


	$a = new person;
	$b = clone $a; 	
	if( $a == $b ){
		echo 'Yes';
	}else{
		echo 'No';
	}

	$b->name = '小王';
	var_dump($a, $b);

	echo '<hr>';

	// 标识符
	$a = new person;
	$b = clone $a;
	$c = $a; 	//  将 $a 的标识赋给了 $c
	var_dump($a, $b, $c);
	echo '<hr>';

	// 公用同一标识的对象 全部收到影响
	$a->name = '大王';
	var_dump($a, $b, $c);
	echo '<hr>';

	// 删除其中一个对象
	unset($a); 		// 只是删除 $a 与 标识之间的联系.    标识与内存之间联系依旧存在
	var_dump($a, $b, $c);

    魔术方法: 在克隆时, 自动触发 __clone 
 		作用: 克隆时, 重新对属性做初始化
```
**instanceof**
```
    运算符instanceof
    作用：滴血认亲
    判断对象是否属于类/对象
    
    
```
**serlalize**
```
串行化（序列化）对象
将对象转化为字符串，用于存储数据库，数据传输...
serialize()对象->字符串
__sleep()
unserialize  字符串->对象
__wakeup()
在串行化时，只能串属性，不能串方法，方法并未丢失，只是隐藏


O：object 
6:类名的长度
person 类名
3：属性的个数
s:字符串
4：name的长度
6：老王的字节长度
// O:6:"person":3:{s:4:"name";s:6:"老王";s:12:" person wife";s:6:"老马";s:6:" * son";s:6:"小强";}


// O:6:"person":3:
	// {
	// 	s:4:"name";
	// 	s:6:"老王";
	// 	
	// 	s:12:"personwife"; 			私有属性 :   类名 + 属性名
	// 	s:6:"老马";
	// 	
	// 	s:6:"*son"; 				受保护   :   * + 属性名
	// 	s:6:"小强";
	// }


```
**自动加载类**
```
// 魔术方法: 自动加载类 __autoload
	// 			 在实例化不存在的类时, 自动触发
	// 格式:
	// 	function __autoload()
	// 	{
	// 		
	// 	}
	
	// 一个文件中, 可能会使用到 多个类
	// 常规: 
	// 	1. 一个类文件内只有一个类
	// 	2. 类名与文件名 必然会有联系
	
	
	// 文件加载过多的情况下, 操作繁琐
	// include 'upload.php';
	// include 'image.php';
	// include 'db.php';
	

	function __autoload($class)
	{
		// var_dump($class);
		include './'.$class.'.php';
	}
	

	// 文件上传类
	$upload = new upload;
	// 验证码类
	$image = new image;
	// 数据库类
	$db = new db;
```
**abstract**
```
    抽象类：
        abstract
        含有抽象方法的类必须是抽象类
        抽象类并不一定含有抽象方法
        作用：本身不让用，强制让派生类先完善抽象方法，再使用
        
```
**异常处理**
```
    try{
        捕获异常
    }catch(Exception 对象){
        处理异常
    }
    执行原理：当try捕获到异常时，自动跳转到catch处
    
    如何捕获异常：
        主动捕获：自动判断代码
        主动抛出：throw new Exception()
        
        异常类：Exception
        方法：getMessage
              getLine
              getFile
              getCode
    try{

		// 自动捕获
			// $dsn = 'mysql:host=localhost;dbname=s76-2;charset=utf8';
			// $dsn = 'mysql:host=localhost;dbname=76-2;charset=utf8';
			// $user = 'root';
			// $pwd = '';
			// $pdo = new PDO($dsn, $user, $pwd);
			// var_dump($pdo);
		
		// 主动抛出异常
			throw new Exception('想进入玩玩', '10086');

	}catch(Exception $e){ // $e = new Exception
		echo '此处为 异常处理处 <br>';
		echo $e->getMessage(); 	// 获取错误信息
		echo '<br>';
		echo $e->getFile(); 	// 获取错误地址
		echo '<br>';
		echo $e->getLine(); 	// 获取错误行号
		echo '<br>';
		echo $e->getCode(); 	// 获取错误编号
	}


	echo '<hr>';
              
```
**事务**
```
// 事务
	//  	将 多条sql(增删改)语句, 作为一个整体单元来操作
	//  
	// MySQL 默认所有命令一旦提交, 立马生效
	// 	取消自动提交
	// 	PDO::setAttribute(PDO::ATTR_AUTOCOMMIT, 0) 	
	// 	
	// 	开启自动提交
	// 	PDO::setAttribute(PDO::ATTR_AUTOCOMMIT, 1) 	
	
	// 事务步骤
	// 	1. 关闭自动提交
	// 		PDO::setAttribute(PDO::ATTR_AUTOCOMMIT, 0) 	
	// 
	// 	2. 开启一个事务
	// 		PDO::beginTransaction()
	// 	
	// 	3. 提交一个事务
	// 		PDO::commit()
	// 	
	// 	3. 回滚一个事务
	// 		PDO::rollBack()
	// 
	//  4. 开启自动提交
	// 		PDO::setAttribute(PDO::ATTR_AUTOCOMMIT, 1) 	
	
	
	
	
	$pdo = new PDO('mysql:host=localhost;dbname=s76-2;charset=utf8','root','');

	// 1. 关闭自动提交
		$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 0);

	try {
		// 开启一个事务
		$pdo->beginTransaction();

		// 百度 扣钱
			$sql = 'update money set `money`= `money`-10000  where id = 1 ';
			// $sql = 'update money set `money`= `mony`-10000  where id = 1 ';
			$res = $pdo->exec($sql);
			if( !$res ){
				throw new Exception('工资转出失败');
			}

		// 周垚 收钱
			// $sql = 'update money set `money` = `money` + 10000 where id = 2';
			$sql = 'update money set `money` = `moey` + 10000 where id = 2';
			$res = $pdo->exec($sql);
			if( !$res ){
				throw new Exception('工资转入失败');
			}

		// 提交一个事务
			$pdo->commit();

	} catch (Exception $e) {
		
		echo $e->getMessage();

		// 回滚一个事务
		$pdo->rollBack();
	}

	// 开启自动提交
		$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 1);

```

**单例模式**
```
// 设计模式
	// 	单例模式
	//  	定义:  多次实例化, 只会保留一个对象
	

	// 1. 防止用户在外面new 			修改修饰符
	// 2. 实现 构造使用					new self
	// 3. 防止多次静态调用				标志属性



	class mysql
	{
		private static $link = null;

		private function __construct()
		{
			echo '数据库连接成功... <br>';
		}

		static public function getConnect()
		{
			// link 为空, 则证明 从没连接过, 直接new
			// link 非空, 则证明 曾经连接过, 跳过new
			if( is_null( self::$link ) ){
				self::$link = new self;
			}
			return self::$link;
		}
	}

	// $a = new mysql;
	// $a = new mysql;
	// $a = new mysql;

	mysql::getConnect();
	mysql::getConnect();
	mysql::getConnect();
	
```
**COOKIE**
```
    会话控制
        HTTP协议是无状态协议
        HTTP协议不能告诉我们多请求是否来自同一个客户端
        
    会话控制
    允许服务器跟踪同一个客户端做出的连续请求
    分类：
        cookie 客户端
        session 服务端
    设置cookie
    setcookie(cookie名，cookie值，生命周期，路径，域名)
    
    // 删除cookie 
		// unset( $_COOKIE['pwd'] );  		// 只是删除了服务器上临时的cookie数据, 并非真正的删除, cookie存在客户端
	
		// 真正删除cookie, 调整cookie的生命周期, 调为过去式
		setcookie('pwd', '', time()-1 );

```
**SESSION**
```
// session  服务端
	// 	session 默认是关闭的
	// 	开启session
		session_start();

	// 设置session	
		$_SESSION['userName'] = 'xiaozhang';
		$_SESSION['age'] = 18;

	// 删除session
		unset($_SESSION['age']); 	// 可以单个删除
		// unset($_SESSION); 		不能直接删除整个session,  预定义数组

	// 查看session
	var_dump($_SESSION);

	// 生命周期
	// 	session.gc_maxlifetime = 1440 	约24分钟
```